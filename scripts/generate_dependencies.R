#!/usr/bin/env Rscript

## Parse the dependencies of each PEcAn package as listed in DESCRIPTION files,
##    and update two scripts to match:
## * Makefile.depends, which tracks the dependencies between PEcAn packages
##    so that Make can install them in the correct order
## * docker/depends/pecan.depends.R. which preinstalls non-PEcAn dependencies
##    on the Docker image (or on other systems if you call it directly).
## Run this script after each time you change a DESCRIPTION,
##    and commit any resulting changes to Makefile.depends or pecan.depends.R





# Get remote refs from a package description,
# formatted for install_github.
# @param pkg_desc as read by `desc::desc`
# @return vector of remote refs,
#   with names set to their (inferred) package names
extract_remotes <- function(pkg_desc) {
  remote_sources <- pkg_desc$get_remotes()
  non_gh <- !grepl("^github::", remote_sources)
  if (any(non_gh)) {
      warning(
        "Found `Remotes` address pointing to non-Github repo: ",
        remote_sources[non_gh],
        "pecan.depends.R only supports github remotes so far, ",
        "so skipping.")
  }

  sub("^github::", "", remote_sources[!non_gh])
}


# Read DESCRIPTION file, return a list of:
#   strings `pkgname`, `dirname`
#   character vectors `pecan_deps`, `gh_deps`
#   data frame `deps`, with columns
#     `type`, `package`, `version`, `needed_by_dir`, `is_pecan`, `is_remote`
parse_desc <- function(path) {
  d <- desc::desc(file = path)
  deps <- d$get_deps()
  deps$needed_by_dir <- dirname(path)

  # Find packages listed as remote
  remote_sources <- extract_remotes(d)
  # deps$is_remote <- deps$package %in% names(remote_sources)

  list(
    mapping = data.frame(
      package = d$get_field("Package"),
      package_dir = dirname(path)),
    remotes = remote_sources,
    deps = deps)
}


# find the latest of several possible minimum package versions
condense_version_requirements <- function(specs) {
  if (all(specs ==  "*")) {
    # any version is acceptable
    return("*")
  }
  specs <- unique(specs[specs != "*"])
  if (any(!grepl(">", specs))) {
    # we *could* write more to handle this case if needed, but it seems very rare:
    # Zero of the 477 packages in my R library declare a `<=` or `==`
    stop(
      "generate_dependencies only supports minimum versions (e.g. `>= 2.8.1`), ",
      "not exact (`==`) or maximum versions (`<=`).",
      "Problem seen in (", paste(dQuote(specs), collapse = ", "), ")")
  }
  versions <- package_version(
    gsub("[^[:digit:].-]+", "", specs))

  specs[versions == max(versions)]
}





# force sorting to hopefully write lines in same order on every machine
if (capabilities("ICU")) {
  icuSetCollate(locale = "en_US.UTF-8")
} else {
  print("Can not force sorting, this could result in unpredicted results.")
}

# Find all PEcAn packages...
files <- list.files(
  path = c("base", "modules", "models"),
  full.names = TRUE,
  pattern = "^DESCRIPTION$",
  recursive = TRUE
)
# ...but don't do anything with these ones
ignore <- c("modules/data.mining")
files <- files[!(dirname(files) %in% ignore)]


# Read all DESCRIPTIONS and compile all deps into one list
pkgs_parsed <- purrr::map(files, parse_desc)
deps <- pkgs_parsed |>
  purrr:::map_dfr("deps") |>
  # ignore R version requirements (e.g. "Depends: R (>= 3.2.0)")
  dplyr::filter(package != "R") |>
  dplyr::mutate(is_pecan = grepl("^PEcAn", package))



# Map out dependencies between PEcAn packages, write to makefile
pecan_name_map <- purrr::map_dfr(pkgs_parsed, "mapping")
pecan_deps <- deps |>
  dplyr::filter(is_pecan) |>
  dplyr::left_join(pecan_name_map, by = "package") |>
  dplyr::group_by(needed_by_dir) |>
  dplyr::summarize(
    dep_list = paste0(".install/", sort(unique(package_dir)), collapse = " "),
    call_txt = paste0("$(call depends,", unique(needed_by_dir), "): | ", dep_list),
    .groups = "drop") |>
  dplyr::pull(call_txt)

cat(
  c("# autogenerated", pecan_deps),
  file = "Makefile.depends",
  sep = "\n",
  append = FALSE)


# list all the GitHub remotes mentioned by any package,
# to attempt installation from these at start of Docker build
remote_repos <- sapply(pkgs_parsed, \(x)x$remotes) |>
  unlist() |>
  sort()


# For deps used by multiple packages, find a version that works for all
uniq_deps <- deps |>
  dplyr::filter(!is_pecan) |>
  dplyr::group_by(package) |>
  dplyr::summarize(
    version = condense_version_requirements(version),
    .groups = "drop")

# Deps without any restriction on version installed.
# We'll install these with one plain old `install.packages()` call.
unversioned_deps <- uniq_deps[uniq_deps$version == "*",]$package

# Deps that need a set minimum version.
# We'll install these with `remotes::install_version`,
# directing it to look outside our fixed-date CRAN snapshot if
# it can't fill the version req from snapshot versions.
versioned_dep_install_calls <- uniq_deps[uniq_deps$version != "*",] |>
  dplyr::mutate(
    inst_call = paste0(
      "install_if_version(", shQuote(package), ", ", shQuote(version), ")")) |>
  dplyr::pull(inst_call) |>
  sort()



# write for docker dependency image
cat("#!/usr/bin/env Rscript",
    "# autogenerated do not edit",
    "# use scripts/generate_dependencies.R",
    "",
    "# Don\'t use X11 for rgl",
    "Sys.setenv(RGL_USE_NULL = TRUE)",
    "rlib <- Sys.getenv('R_LIBS_USER', '/usr/local/lib/R/site-library')",
    "Sys.setenv(RLIB = rlib)",
    "",
    "# install remotes first in case packages are references in dependencies",
    "remotes::install_github(c(",
    paste(shQuote(sort(remote_repos)), collapse = ",\n"),
    "), lib = rlib)",
    "",
    "# install package listed as Depends, Imports, Suggests of any PEcAn package",
    "#   that do not have a stated version limit",
    "wanted <- c(", paste(shQuote(sort(unversioned_deps)), sep = "", collapse = ",\n"), ")",
    "missing <- wanted[!(wanted %in% installed.packages()[,'Package'])]",
    "install.packages(missing, lib = rlib)",
    "",
    "# Install packages listed as Depends, Imports, Suggests",
    "#    that list a minimum version.",
    "# When the minimum is not satisfied in the fixed-date CRAN snapshot",
    "#    used by our Docker images, we pull it in from an up-to-date mirror.",
    "# (Assumes our CRAN uses the same URL scheme as Posit package manager)",
    "options(repos = c(",
    "    getOption('repos'),",
    "    sub(r'(\\d{4}-\\d{2}-\\d{2})', 'latest', getOption('repos'))",
    "))",
    "install_if_version <- function(pkg, version) {",
    "    vers <- gsub('[^[:digit:].-]+', '', version)",
    "    cmp <- get(gsub('[^<>=]+', '', version))",
    "    ok <- requireNamespace(pkg, quietly = TRUE) &&",
    "        cmp(packageVersion(pkg), vers)",
    "    if (!ok) {",
    "        remotes::install_version(pkg, version, dependencies = TRUE, upgrade = FALSE)",
    "    }",
    "}",
    paste(versioned_dep_install_calls, collapse = "\n"),
    file = "docker/depends/pecan.depends.R", sep = "\n", append = FALSE)
